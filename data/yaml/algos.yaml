# Project catalog moved under data/yaml
# Project catalog moved under data/yaml
envelopes:
  - index: 0
    name: none
    desc: No envelope; prefer selecting this to emit bare byte array
    python_snippet: |
      def envelope(data: bytes) -> str:
          return ""
    cpp_decode: |
      // envelope 'none' is handled in the generator; this is a no-op stub

  - index: 1
    name: base91
    python_snippet: |
      # defines: envelope(data: bytes) -> str
      B91_ALPH = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!#$%&()*+,./:;<=>?@[]^_`{|}~"'
      def envelope(data: bytes) -> str:
          if not data: return ""
          v = 0
          b = 0
          out = []
          for x in data:
              v |= (x & 0xFF) << b
              b += 8
              while b > 13:
                  val = v & 8191
                  if val > 88:
                      v >>= 13; b -= 13
                  else:
                      val = v & 16383; v >>= 14; b -= 14
                  out.append(B91_ALPH[val % 91])
                  out.append(B91_ALPH[val // 91])
          if b:
              out.append(B91_ALPH[v % 91])
              if b > 7 or v > 90:
                  out.append(B91_ALPH[v // 91])
          return "".join(out)
    cpp_decode: |
      const char* B91_ALPH = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!#$%&()*+,./:;<=>?@[]^_`{|}~\"";
      int b91_dec[256];
      for (int i = 0; i < 256; ++i) b91_dec[i] = -1;
      for (int i = 0; i < 91; ++i) b91_dec[(unsigned char)B91_ALPH[i]] = i;

      unsigned int enc_cap = (code_blob_text_len * 13u) / 14u + 8u;
      unsigned char* enc_buf = new unsigned char[enc_cap];
      unsigned int enc_len = 0;

      unsigned int b = 0, n = 0;
      int v = -1;
      for (unsigned int i = 0; i < code_blob_text_len; ++i) {
          unsigned char c = (unsigned char)code_blob_text[i];
          int d = (c < 256) ? b91_dec[c] : -1;
          if (d < 0) continue;
          if (v < 0) v = d;
          else {
              v += d * 91;
              b |= (unsigned int)v << n;
              n += ((v & 8191) > 88) ? 13u : 14u;
              do {
                  enc_buf[enc_len++] = (unsigned char)(b & 0xFFu);
                  b >>= 8u;
                  n -= 8u;
              } while (n > 7u);
              v = -1;
          }
      }
      if (v >= 0) {
          enc_buf[enc_len++] = (unsigned char)((b | (unsigned int)v << n) & 0xFFu);
      }

  - index: 2
    name: base64
    python_snippet: |
      import base64
      def envelope(data: bytes) -> str:
          return base64.b64encode(data).decode('ascii')
    cpp_decode: |
      // naive inline Base64 decode (ASCII only, ignores whitespace)
      int B64_DEC[256]; for (int i=0;i<256;++i) B64_DEC[i]=-1;
      {
          const char* alpha="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
          for (int i=0;i<64;++i) B64_DEC[(unsigned char)alpha[i]] = i;
      }
      unsigned char* enc_buf = new unsigned char[(code_blob_text_len * 3u)/4u + 3u];
      unsigned int enc_len = 0;
      unsigned int val = 0; int valb = -8;
      for (unsigned int i=0;i<code_blob_text_len;++i){
          int d = B64_DEC[(unsigned char)code_blob_text[i]];
          if (d == -1) continue;
          val = (val<<6) | (unsigned)d; valb += 6;
          if (valb >= 0) {
              enc_buf[enc_len++] = (unsigned char)((val>>valb)&0xFFu);
              valb -= 8;
          }
      }

  - index: 3
    name: base32
    python_snippet: |
      import base64
      def envelope(data: bytes) -> str:
          return base64.b32encode(data).decode('ascii')
    cpp_decode: |
      // naive inline Base32 decode (RFC 4648 alphabet), ignores non-alphabet and '=' padding
      int B32_DEC[256]; for (int i=0;i<256;++i) B32_DEC[i] = -1;
      {
          const char* alpha = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
          for (int i=0;i<32;++i) B32_DEC[(unsigned char)alpha[i]] = i;
      }
      unsigned int enc_cap = (code_blob_text_len * 5u) / 8u + 8u;
      unsigned char* enc_buf = new unsigned char[enc_cap];
      unsigned int enc_len = 0;
      unsigned int val = 0; int valb = -8;
      for (unsigned int i=0;i<code_blob_text_len;++i) {
          unsigned char c = (unsigned char)code_blob_text[i];
          if (c == '=') continue; // skip padding
          int d = B32_DEC[c];
          if (d == -1) continue; // skip non-alphabet
          val = (val << 5) | (unsigned)d; valb += 5;
          if (valb >= 0) {
              enc_buf[enc_len++] = (unsigned char)((val >> valb) & 0xFFu);
              valb -= 8;
          }
      }

encoders:
  - index: 0
    name: none
    desc: No encoding (pass-through)
    python_snippet: |
      def encode(data: bytes, keys: dict) -> bytes:
          return data
    cpp_inverse: |
      unsigned char* code_blob = new unsigned char[enc_len];
      unsigned int code_blob_len = enc_len;
      for (unsigned int i = 0; i < enc_len; ++i) {
          code_blob[i] = enc_buf[i];
      }
  - index: 1
    name: xor
    keys_snippet: |
      import os
      def gen_keys():
          return {"xor_key": os.urandom(16)}
    python_snippet: |
      def encode(data: bytes, keys: dict) -> bytes:
          k = keys["xor_key"]
          return bytes(d ^ k[i % len(k)] for i, d in enumerate(data))
    cpp_inverse: |
      unsigned char* code_blob = new unsigned char[enc_len];
      unsigned int code_blob_len = enc_len;
      for (unsigned int i = 0; i < enc_len; ++i) {
          code_blob[i] = enc_buf[i] ^ {xor_key}[i % {xor_key_len}];
      }

  - index: 2
    name: xor2
    keys_snippet: |
      import os
      def gen_keys():
          return {"xor_key1": os.urandom(16), "xor_key2": os.urandom(16)}
    python_snippet: |
      def encode(data: bytes, keys: dict) -> bytes:
          k1, k2 = keys["xor_key1"], keys["xor_key2"]
          tmp = bytes(d ^ k1[i % len(k1)] for i, d in enumerate(data))
          out = bytes(d ^ k2[i % len(k2)] for i, d in enumerate(tmp))
          return out
    cpp_inverse: |
      unsigned char* code_blob = new unsigned char[enc_len];
      unsigned int code_blob_len = enc_len;
      for (unsigned int i = 0; i < enc_len; ++i) {
          unsigned char b = enc_buf[i] ^ {xor_key2}[i % {xor_key2_len}];
          code_blob[i] = b ^ {xor_key1}[i % {xor_key1_len}];
      }

  - index: 3
    name: arx8
    keys_snippet: |
      import os
      def gen_keys():
          return {"arx_key": os.urandom(16)}
    python_snippet: |
      def encode(data: bytes, keys: dict) -> bytes:
          key = keys["arx_key"]
          out = bytearray(len(data))
          for i, b in enumerate(data):
              k = key[i & 15]
              r = (k ^ i) & 7
              bp = (b + k) & 0xFF
              bp = ((bp << r) | (bp >> (8 - r))) & 0xFF if r else bp
              bp ^= (k + i) & 0xFF
              out[i] = bp
          return bytes(out)
    cpp_inverse: |
      unsigned char* code_blob = new unsigned char[enc_len];
      unsigned int code_blob_len = enc_len;
      for (unsigned int i = 0; i < enc_len; ++i) {
          unsigned char k = {arx_key}[i & 15];
          unsigned char r = (unsigned char)((k ^ i) & 7);
          unsigned char b = enc_buf[i];
          b ^= (unsigned char)(k + (unsigned char)i);
          if (r) b = (unsigned char)((b >> r) | (b << (8 - r))); // rotr8
          b = (unsigned char)(b - k);
          code_blob[i] = b;
      }

  - index: 4
    name: arx82
    keys_snippet: |
      import os
      def gen_keys():
          return {"arx_key1": os.urandom(16), "arx_key2": os.urandom(16)}
    python_snippet: |
      def encode(data: bytes, keys: dict) -> bytes:
          k1, k2 = keys["arx_key1"], keys["arx_key2"]
          def arx_once(dat, key):
              out = bytearray(len(dat))
              for i, b in enumerate(dat):
                  kk = key[i & 15]
                  r = (kk ^ i) & 7
                  bp = (b + kk) & 0xFF
                  bp = ((bp << r) | (bp >> (8 - r))) & 0xFF if r else bp
                  bp ^= (kk + i) & 0xFF
                  out[i] = bp
              return bytes(out)
          return arx_once(arx_once(data, k1), k2)
    cpp_inverse: |
      unsigned char* code_blob = new unsigned char[enc_len];
      unsigned int code_blob_len = enc_len;
      /* invert pass 2 (key2) */
      for (unsigned int i = 0; i < enc_len; ++i) {
          unsigned char k = {arx_key2}[i & 15];
          unsigned char r = (unsigned char)((k ^ i) & 7);
          unsigned char b = enc_buf[i];
          b ^= (unsigned char)(k + (unsigned char)i);
          if (r) b = (unsigned char)((b >> r) | (b << (8 - r))); // rotr8
          b = (unsigned char)(b - k);
          code_blob[i] = b;
      }
      /* invert pass 1 (key1) */
      for (unsigned int i = 0; i < enc_len; ++i) {
          unsigned char k = {arx_key1}[i & 15];
          unsigned char r = (unsigned char)((k ^ i) & 7);
          unsigned char b = code_blob[i];
          b ^= (unsigned char)(k + (unsigned char)i);
          if (r) b = (unsigned char)((b >> r) | (b << (8 - r))); // rotr8
          b = (unsigned char)(b - k);
          code_blob[i] = b;
      }
